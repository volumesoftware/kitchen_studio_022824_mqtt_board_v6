{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/continuous-toolbox/webpack/universalModuleDefinition","webpack://@blockly/continuous-toolbox/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/continuous-toolbox/webpack/bootstrap","webpack://@blockly/continuous-toolbox/webpack/runtime/define property getters","webpack://@blockly/continuous-toolbox/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/continuous-toolbox/webpack/runtime/make namespace object","webpack://@blockly/continuous-toolbox/./src/ContinuousCategory.js","webpack://@blockly/continuous-toolbox/./src/ContinuousToolbox.js","webpack://@blockly/continuous-toolbox/./src/ContinuousMetricsFlyout.js","webpack://@blockly/continuous-toolbox/./src/ContinuousFlyout.js","webpack://@blockly/continuous-toolbox/./src/ContinuousMetrics.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox category with styling for continuous toolbox.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Toolbox category for continuous toolbox. */\nexport class ContinuousCategory extends Blockly.ToolboxCategory {\n  /**\n   * Constructor for ContinuousCategory which is used in ContinuousToolbox.\n   * @override\n   */\n  constructor(categoryDef, toolbox) {\n    super(categoryDef, toolbox);\n  }\n\n  /** @override */\n  createLabelDom_(name) {\n    const label = document.createElement('div');\n    label.setAttribute('id', this.getId() + '.label');\n    label.textContent = name;\n    label.classList.add(this.cssConfig_['label']);\n    return label;\n  }\n\n  /** @override */\n  createIconDom_() {\n    const icon = document.createElement('div');\n    icon.classList.add('categoryBubble');\n    icon.style.backgroundColor = this.colour_;\n    return icon;\n  }\n\n  /** @override */\n  addColourBorder_() {\n    // No-op\n  }\n\n  /** @override */\n  setSelected(isSelected) {\n    if (isSelected) {\n      this.rowDiv_.style.backgroundColor = 'gray';\n      Blockly.utils.dom.addClass(this.rowDiv_, this.cssConfig_['selected']);\n    } else {\n      this.rowDiv_.style.backgroundColor = '';\n      Blockly.utils.dom.removeClass(this.rowDiv_, this.cssConfig_['selected']);\n    }\n    Blockly.utils.aria.setState(\n      /** @type {!Element} */ (this.htmlDiv_),\n      Blockly.utils.aria.State.SELECTED,\n      isSelected,\n    );\n  }\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.TOOLBOX_ITEM,\n  Blockly.ToolboxCategory.registrationName,\n  ContinuousCategory,\n  true,\n);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox that uses a continuous scrolling flyout.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousFlyout} from './ContinuousFlyout';\n\n/**\n * Class for continuous toolbox.\n */\nexport class ContinuousToolbox extends Blockly.Toolbox {\n  /** @override */\n  constructor(workspace) {\n    super(workspace);\n  }\n\n  /** @override */\n  init() {\n    super.init();\n\n    // Populate the flyout with all blocks and show it immediately.\n    const flyout = this.getFlyout();\n    flyout.show(this.getInitialFlyoutContents_());\n    flyout.recordScrollPositions();\n\n    this.workspace_.addChangeListener((e) => {\n      if (\n        e.type === Blockly.Events.BLOCK_CREATE ||\n        e.type === Blockly.Events.BLOCK_DELETE\n      ) {\n        this.refreshSelection();\n      }\n    });\n  }\n\n  /** @override */\n  getFlyout() {\n    return /** @type {ContinuousFlyout} */ (super.getFlyout());\n  }\n\n  /**\n   * Gets the contents that should be shown in the flyout immediately.\n   * This includes all blocks and labels for each category of block.\n   * @returns {!Blockly.utils.toolbox.FlyoutItemInfoArray} Flyout contents.\n   * @private\n   */\n  getInitialFlyoutContents_() {\n    /** @type {!Blockly.utils.toolbox.FlyoutItemInfoArray} */\n    let contents = [];\n    for (const toolboxItem of this.contents_) {\n      if (toolboxItem instanceof Blockly.ToolboxCategory) {\n        // Create a label node to go at the top of the category\n        contents.push({kind: 'LABEL', text: toolboxItem.getName()});\n        /**\n         * @type {string|Blockly.utils.toolbox.FlyoutItemInfoArray|\n         *    Blockly.utils.toolbox.FlyoutItemInfo}\n         */\n        let itemContents = toolboxItem.getContents();\n\n        // Handle custom categories (e.g. variables and functions)\n        if (typeof itemContents === 'string') {\n          itemContents =\n            /** @type {!Blockly.utils.toolbox.DynamicCategoryInfo} */ ({\n              custom: itemContents,\n              kind: 'CATEGORY',\n            });\n        }\n        contents = contents.concat(itemContents);\n      }\n    }\n    return contents;\n  }\n\n  /** @override */\n  refreshSelection() {\n    this.getFlyout().show(this.getInitialFlyoutContents_());\n  }\n\n  /** @override */\n  updateFlyout_(_oldItem, newItem) {\n    if (newItem) {\n      const target = this.getFlyout().getCategoryScrollPosition(\n        newItem.name_,\n      ).y;\n      this.getFlyout().scrollTo(target);\n    }\n  }\n\n  /** @override */\n  shouldDeselectItem_(oldItem, newItem) {\n    // Should not deselect if the same category is clicked again.\n    return oldItem && oldItem !== newItem;\n  }\n\n  /**\n   * Gets a category by name.\n   * @param {string} name Name of category to get.\n   * @returns {?Blockly.ToolboxCategory} Category, or null if not\n   *    found.\n   * @package\n   */\n  getCategoryByName(name) {\n    const category = this.contents_.find(\n      (item) =>\n        item instanceof Blockly.ToolboxCategory &&\n        item.isSelectable() &&\n        name === item.getName(),\n    );\n    if (category) {\n      return /** @type {!Blockly.ToolboxCategory} */ (category);\n    }\n    return null;\n  }\n\n  /**\n   * Selects the category with the given name.\n   * Similar to setSelectedItem, but importantly, does not call updateFlyout\n   * because this is called while the flyout is being scrolled.\n   * @param {string} name Name of category to select.\n   * @package\n   */\n  selectCategoryByName(name) {\n    const newItem = this.getCategoryByName(name);\n    if (!newItem) {\n      return;\n    }\n    const oldItem = this.selectedItem_;\n\n    if (this.shouldDeselectItem_(oldItem, newItem)) {\n      this.deselectItem_(oldItem);\n    }\n\n    if (this.shouldSelectItem_(oldItem, newItem)) {\n      this.selectItem_(oldItem, newItem);\n    }\n  }\n\n  /** @override */\n  getClientRect() {\n    // If the flyout never closes, it should be the deletable area.\n    const flyout = this.getFlyout();\n    if (flyout && !flyout.autoClose) {\n      return flyout.getClientRect();\n    }\n    return super.getClientRect();\n  }\n}\n\nBlockly.Css.register(`\n.categoryBubble {\n  margin: 0 auto 0.125rem;\n  border-radius: 100%;\n  border: 1px solid;\n  width: 1.25rem;\n  height: 1.25rem;\n}\n.blocklyTreeRow {\n  height: initial;\n  padding: 3px 0;\n}\n.blocklyTreeRowContentContainer {\n  display: flex;\n  flex-direction: column;\n}\n.blocklyTreeLabel {\n  margin: auto;\n}\n`);\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Adds additional padding to the bottom of the flyout if needed. */\nexport class ContinuousFlyoutMetrics extends Blockly.FlyoutMetricsManager {\n  /** @override */\n  constructor(workspace, flyout) {\n    super(workspace, flyout);\n  }\n  /**\n   * Adds additional padding to the bottom of the flyout if needed,\n   * in order to make it possible to scroll to the top of the last category.\n   * @override\n   */\n  getScrollMetrics(\n    getWorkspaceCoordinates = undefined,\n    cachedViewMetrics = undefined,\n    cachedContentMetrics = undefined,\n  ) {\n    const scrollMetrics = super.getScrollMetrics(\n      getWorkspaceCoordinates,\n      cachedViewMetrics,\n      cachedContentMetrics,\n    );\n    const contentMetrics =\n      cachedContentMetrics || this.getContentMetrics(getWorkspaceCoordinates);\n    const viewMetrics =\n      cachedViewMetrics || this.getViewMetrics(getWorkspaceCoordinates);\n\n    if (scrollMetrics) {\n      scrollMetrics.height += this.flyout_.calculateBottomPadding(\n        contentMetrics,\n        viewMetrics,\n      );\n    }\n    return scrollMetrics;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Flyout that supports always-open continuous scrolling.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousToolbox} from './ContinuousToolbox';\nimport {ContinuousFlyoutMetrics} from './ContinuousMetricsFlyout';\n\n/**\n * Class for continuous flyout.\n */\nexport class ContinuousFlyout extends Blockly.VerticalFlyout {\n  /** @override */\n  constructor(workspaceOptions) {\n    super(workspaceOptions);\n\n    /**\n     * List of scroll positions for each category.\n     * @type {!Array<{name: string, position: !Object}>}\n     */\n    this.scrollPositions = [];\n\n    /**\n     * Target scroll position, used to smoothly scroll to a given category\n     * location when selected.\n     * @type {?number}\n     */\n    this.scrollTarget = null;\n\n    /**\n     * The percentage of the distance to the scrollTarget that should be\n     * scrolled at a time. Lower values will produce a smoother, slower scroll.\n     * @type {number}\n     */\n    this.scrollAnimationFraction = 0.3;\n\n    /**\n     * Whether to recycle blocks when refreshing the flyout. When false, do not\n     * allow anything to be recycled. The default is to recycle.\n     * @type {boolean}\n     * @private\n     */\n    this.recyclingEnabled_ = true;\n\n    this.workspace_.setMetricsManager(\n      new ContinuousFlyoutMetrics(this.workspace_, this),\n    );\n\n    this.workspace_.addChangeListener((e) => {\n      if (e.type === Blockly.Events.VIEWPORT_CHANGE) {\n        this.selectCategoryByScrollPosition_(-this.workspace_.scrollY);\n      }\n    });\n\n    this.autoClose = false;\n  }\n\n  /**\n   * Gets parent toolbox.\n   * Since we registered the ContinuousToolbox, we know that's its type.\n   * @returns {!ContinuousToolbox} Toolbox that owns this flyout.\n   * @private\n   */\n  getParentToolbox_() {\n    const toolbox = this.targetWorkspace.getToolbox();\n    return /** @type {!ContinuousToolbox} */ (toolbox);\n  }\n\n  /**\n   * Records scroll position for each category in the toolbox.\n   * The scroll position is determined by the coordinates of each category's\n   * label after the entire flyout has been rendered.\n   * @package\n   */\n  recordScrollPositions() {\n    this.scrollPositions = [];\n    const categoryLabels = this.buttons_.filter(\n      (button) =>\n        button.isLabel() &&\n        this.getParentToolbox_().getCategoryByName(button.getButtonText()),\n    );\n    for (const [index, button] of categoryLabels.entries()) {\n      if (button.isLabel()) {\n        const position = button.getPosition();\n        const adjustedPosition = new Blockly.utils.Coordinate(\n          position.x,\n          position.y - this.labelGaps[index],\n        );\n        this.scrollPositions.push({\n          name: button.getButtonText(),\n          position: adjustedPosition,\n        });\n      }\n    }\n  }\n\n  /**\n   * Returns the scroll position for the given category name.\n   * @param {string} name Category name.\n   * @returns {?Object} Scroll position for given category, or null if not\n   *     found.\n   * @package\n   */\n  getCategoryScrollPosition(name) {\n    for (const scrollInfo of this.scrollPositions) {\n      if (scrollInfo.name === name) {\n        return scrollInfo.position;\n      }\n    }\n    console.warn(`Scroll position not recorded for category ${name}`);\n    return null;\n  }\n\n  /**\n   * Selects an item in the toolbox based on the scroll position of the flyout.\n   * @param {number} position Current scroll position of the workspace.\n   * @private\n   */\n  selectCategoryByScrollPosition_(position) {\n    // If we are currently auto-scrolling, due to selecting a category by\n    // clicking on it, do not update the category selection.\n    if (this.scrollTarget !== null) {\n      return;\n    }\n    const scaledPosition = Math.round(position / this.workspace_.scale);\n    // Traverse the array of scroll positions in reverse, so we can select the\n    // furthest category that the scroll position is beyond.\n    for (let i = this.scrollPositions.length - 1; i >= 0; i--) {\n      const category = this.scrollPositions[i];\n      if (scaledPosition >= category.position.y) {\n        this.getParentToolbox_().selectCategoryByName(category.name);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Scrolls flyout to given position.\n   * @param {number} position The Y coordinate to scroll to.\n   */\n  scrollTo(position) {\n    // Set the scroll target to either the scaled position or the lowest\n    // possible scroll point, whichever is smaller.\n    const metrics = this.workspace_.getMetrics();\n    this.scrollTarget = Math.min(\n      position * this.workspace_.scale,\n      metrics.scrollHeight - metrics.viewHeight,\n    );\n\n    this.stepScrollAnimation_();\n  }\n\n  /**\n   * Step the scrolling animation by scrolling a fraction of the way to\n   * a scroll target, and request the next frame if necessary.\n   * @private\n   */\n  stepScrollAnimation_() {\n    if (this.scrollTarget === null) {\n      return;\n    }\n\n    const currentScrollPos = -this.workspace_.scrollY;\n    const diff = this.scrollTarget - currentScrollPos;\n    if (Math.abs(diff) < 1) {\n      this.workspace_.scrollbar.setY(this.scrollTarget);\n      this.scrollTarget = null;\n      return;\n    }\n    this.workspace_.scrollbar.setY(\n      currentScrollPos + diff * this.scrollAnimationFraction,\n    );\n\n    requestAnimationFrame(this.stepScrollAnimation_.bind(this));\n  }\n\n  /**\n   * Add additional padding to the bottom of the flyout if needed,\n   * in order to make it possible to scroll to the top of the last category.\n   * @param {!Blockly.MetricsManager.ContainerRegion} contentMetrics Content\n   *    metrics for the flyout.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *    for the flyout.\n   * @returns {number} Additional bottom padding.\n   */\n  calculateBottomPadding(contentMetrics, viewMetrics) {\n    if (this.scrollPositions.length > 0) {\n      const lastCategory =\n        this.scrollPositions[this.scrollPositions.length - 1];\n      const lastPosition = lastCategory.position.y * this.workspace_.scale;\n      const lastCategoryHeight = contentMetrics.height - lastPosition;\n      if (lastCategoryHeight < viewMetrics.height) {\n        return viewMetrics.height - lastCategoryHeight;\n      }\n    }\n    return 0;\n  }\n\n  /** @override */\n  getX() {\n    if (\n      this.isVisible() &&\n      this.targetWorkspace.toolboxPosition === this.toolboxPosition_ &&\n      this.targetWorkspace.getToolbox() &&\n      this.toolboxPosition_ !== Blockly.utils.toolbox.Position.LEFT\n    ) {\n      // This makes it so blocks cannot go under the flyout in RTL mode.\n      return this.targetWorkspace.getMetricsManager().getViewMetrics().width;\n    }\n\n    return super.getX();\n  }\n\n  /**\n   * @override\n   */\n  show(flyoutDef) {\n    super.show(flyoutDef);\n    this.recordScrollPositions();\n    this.workspace_.resizeContents();\n    this.selectCategoryByScrollPosition_(0);\n  }\n\n  /**\n   * Determine if this block can be recycled in the flyout.  Blocks that have no\n   * variables and are not dynamic shadows can be recycled.\n   * @param {!Blockly.BlockSvg} block The block to attempt to recycle.\n   * @returns {boolean} True if the block can be recycled.\n   * @protected\n   */\n  blockIsRecyclable_(block) {\n    if (!this.recyclingEnabled_) {\n      return false;\n    }\n\n    // If the block needs to parse mutations, never recycle.\n    if (block.mutationToDom && block.domToMutation) {\n      return false;\n    }\n\n    if (!block.isEnabled()) {\n      return false;\n    }\n\n    for (const input of block.inputList) {\n      for (const field of input.fieldRow) {\n        // No variables.\n        if (field.referencesVariables()) {\n          return false;\n        }\n        if (field instanceof Blockly.FieldDropdown) {\n          if (field.isOptionListDynamic()) {\n            return false;\n          }\n        }\n      }\n      // Check children.\n      if (input.connection) {\n        const targetBlock =\n          /** @type {Blockly.BlockSvg} */\n          (input.connection.targetBlock());\n        if (targetBlock && !this.blockIsRecyclable_(targetBlock)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Sets the function used to determine whether a block is recyclable.\n   * @param {function(!Blockly.BlockSvg):boolean} func The function used to\n   *     determine if a block is recyclable.\n   * @public\n   */\n  setBlockIsRecyclable(func) {\n    this.blockIsRecyclable_ = func;\n  }\n\n  /**\n   * Set whether the flyout can recycle blocks.\n   * @param {boolean} isEnabled True to allow blocks to be recycled, false\n   *     otherwise.\n   * @public\n   */\n  setRecyclingEnabled(isEnabled) {\n    this.recyclingEnabled_ = isEnabled;\n  }\n\n  /**\n   * Lay out the blocks in the flyout.\n   * @param {Array<Blockly.Flyout.FlyoutItem>} contents The blocks and buttons to lay out.\n   * @param {Array<number>} gaps The visible gaps between blocks.\n   */\n  layout_(contents, gaps) {\n    super.layout_(contents, gaps);\n    this.labelGaps = [];\n    for (const [index, item] of contents.entries()) {\n      if (item.type === 'button' && item.button.isLabel()) {\n        this.labelGaps.push(gaps[index - 1] ?? this.MARGIN);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides metrics to exclude the flyout from the viewport.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Computes metrics for a toolbox with an always open flyout. */\nexport class ContinuousMetrics extends Blockly.MetricsManager {\n  /** @override */\n  constructor(workspace) {\n    super(workspace);\n  }\n  /**\n   * Computes the viewport size to not include the toolbox and the flyout.\n   * The default viewport includes the flyout.\n   * @override\n   */\n  getViewMetrics(getWorkspaceCoordinates = undefined) {\n    const scale = getWorkspaceCoordinates ? this.workspace_.scale : 1;\n    const svgMetrics = this.getSvgMetrics();\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n\n    if (this.workspace_.getToolbox()) {\n      // Note: Not actually supported at this time due to ContinunousToolbox\n      // only supporting a vertical flyout. But included for completeness.\n      if (\n        toolboxPosition == Blockly.TOOLBOX_AT_TOP ||\n        toolboxPosition == Blockly.TOOLBOX_AT_BOTTOM\n      ) {\n        svgMetrics.height -= toolboxMetrics.height + flyoutMetrics.height;\n      } else if (\n        toolboxPosition == Blockly.TOOLBOX_AT_LEFT ||\n        toolboxPosition == Blockly.TOOLBOX_AT_RIGHT\n      ) {\n        svgMetrics.width -= toolboxMetrics.width + flyoutMetrics.width;\n      }\n    }\n    return {\n      height: svgMetrics.height / scale,\n      width: svgMetrics.width / scale,\n      top: -this.workspace_.scrollY / scale,\n      left: -this.workspace_.scrollX / scale,\n    };\n  }\n\n  /**\n   * Moves the absoluteLeft and absoluteTop so they no longer include the\n   * flyout.\n   * @override\n   */\n  getAbsoluteMetrics() {\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n    let absoluteLeft = 0;\n\n    if (\n      this.workspace_.getToolbox() &&\n      toolboxPosition == Blockly.TOOLBOX_AT_LEFT\n    ) {\n      absoluteLeft = toolboxMetrics.width + flyoutMetrics.width;\n    }\n    let absoluteTop = 0;\n    if (\n      this.workspace_.getToolbox() &&\n      toolboxPosition == Blockly.TOOLBOX_AT_TOP\n    ) {\n      absoluteTop = toolboxMetrics.height + flyoutMetrics.height;\n    }\n    return {\n      top: absoluteTop,\n      left: absoluteLeft,\n    };\n  }\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.METRICS_MANAGER,\n  'CustomMetricsManager',\n  ContinuousMetrics,\n);\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ContinuousCategory","constructor","categoryDef","toolbox","super","createLabelDom_","name","label","document","createElement","setAttribute","getId","textContent","classList","add","cssConfig_","createIconDom_","icon","style","backgroundColor","colour_","addColourBorder_","setSelected","isSelected","rowDiv_","ContinuousToolbox","workspace","init","flyout","getFlyout","show","getInitialFlyoutContents_","recordScrollPositions","workspace_","addChangeListener","e","type","refreshSelection","contents","toolboxItem","contents_","push","kind","text","getName","itemContents","getContents","custom","concat","updateFlyout_","_oldItem","newItem","target","getCategoryScrollPosition","name_","y","scrollTo","shouldDeselectItem_","oldItem","getCategoryByName","find","item","isSelectable","selectCategoryByName","selectedItem_","deselectItem_","shouldSelectItem_","selectItem_","getClientRect","autoClose","ContinuousFlyoutMetrics","getScrollMetrics","getWorkspaceCoordinates","cachedViewMetrics","cachedContentMetrics","scrollMetrics","contentMetrics","getContentMetrics","viewMetrics","getViewMetrics","height","flyout_","calculateBottomPadding","ContinuousFlyout","workspaceOptions","scrollPositions","scrollTarget","scrollAnimationFraction","recyclingEnabled_","setMetricsManager","selectCategoryByScrollPosition_","scrollY","getParentToolbox_","targetWorkspace","getToolbox","categoryLabels","buttons_","filter","button","isLabel","getButtonText","index","entries","position","getPosition","adjustedPosition","x","labelGaps","scrollInfo","console","warn","scaledPosition","Math","round","scale","length","category","metrics","getMetrics","min","scrollHeight","viewHeight","stepScrollAnimation_","currentScrollPos","diff","abs","scrollbar","setY","requestAnimationFrame","bind","lastPosition","lastCategoryHeight","getX","isVisible","toolboxPosition","toolboxPosition_","getMetricsManager","width","flyoutDef","resizeContents","blockIsRecyclable_","block","mutationToDom","domToMutation","isEnabled","input","inputList","field","fieldRow","referencesVariables","isOptionListDynamic","connection","targetBlock","setBlockIsRecyclable","func","setRecyclingEnabled","layout_","gaps","MARGIN","ContinuousMetrics","svgMetrics","getSvgMetrics","toolboxMetrics","getToolboxMetrics","flyoutMetrics","getFlyoutMetrics","top","left","scrollX","getAbsoluteMetrics","absoluteLeft","absoluteTop"],"sourceRoot":""}