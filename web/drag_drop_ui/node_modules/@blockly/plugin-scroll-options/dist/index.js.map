{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/plugin-scroll-options/webpack/universalModuleDefinition","webpack://@blockly/plugin-scroll-options/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/plugin-scroll-options/webpack/bootstrap","webpack://@blockly/plugin-scroll-options/webpack/runtime/compat get default export","webpack://@blockly/plugin-scroll-options/webpack/runtime/define property getters","webpack://@blockly/plugin-scroll-options/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/plugin-scroll-options/webpack/runtime/make namespace object","webpack://@blockly/plugin-scroll-options/./src/ScrollMetricsManager.js","webpack://@blockly/plugin-scroll-options/./src/utils.js","webpack://@blockly/plugin-scroll-options/./src/AutoScroll.js","webpack://@blockly/plugin-scroll-options/./src/ScrollBlockDragger.js","webpack://@blockly/plugin-scroll-options/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * The MetricsManager reports various metrics about the workspace. This version\n * of the MetricsManager adds optional cacheing of the workspace content\n * metrics. Cached content metrics are useful if, for example, you are in the\n * middle of dragging a block, but want to get the bounds of the content area as\n * if you hadn't yet picked up the block.\n *\n * To use the cached value of the content metrics instead of calculating new\n * ones, set `useCachedContentMetrics` to true before calling `getMetrics`\n * false when the metrics can be recalculated again.\n */\nexport class ScrollMetricsManager extends Blockly.MetricsManager {\n  /** @override */\n  constructor(workspace) {\n    super(workspace);\n\n    /**\n     * Whether to stop recalculating content metrics and used the cached value\n     * instead. Note that if there are no cached metrics, they will be\n     * recalculated even if this value is true.\n     * @type {boolean}\n     */\n    this.useCachedContentMetrics = false;\n\n    /**\n     * Cached content metrics, if available.\n     * @type {?Blockly.MetricsManager.ContainerRegion}\n     */\n    this.contentMetrics = null;\n  }\n\n  /** @override */\n  getContentMetrics() {\n    if (this.useCachedContentMetrics && this.contentMetrics) {\n      return this.contentMetrics;\n    }\n\n    this.contentMetrics = super.getContentMetrics();\n    return this.contentMetrics;\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Gets the current location of the workspace considering\n * when there's no drag surface.\n * @param {!Blockly.WorkspaceSvg} ws The workspace to calculate.\n * @returns {!Blockly.utils.Coordinate} The current workspace coordinate.\n */\nexport const getTranslation = (ws) => {\n  // TODO(blockly/#7157): We should maybe make getBlockCanvas public?\n  const translation = ws.svgBlockCanvas_.getAttribute('transform');\n\n  // Translation has the format 'translate(x, y)'.\n  const splitted = translation.split(',');\n  const x = Number(splitted[0].split('(')[1]);\n  const y = Number(splitted[1].split(')')[0]);\n  return new Blockly.utils.Coordinate(x, y);\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ScrollMetricsManager} from './ScrollMetricsManager';\nimport {getTranslation} from './utils';\n\n/**\n * AutoScroll is used to scroll/pan the workspace automatically. For example,\n * when a user drags a block near the edge of the workspace, it can begin\n * automatically scrolling in that direction.\n *\n * Call `updateProperties` with a vector containing scroll velocity in each\n * direction, in pixels per ms. AutoScroll will use animation frames to smoothly\n * scroll the workspace at a constant velocity. Call `stopAndDestroy` to cancel\n * the AutoScroll animation. You must ensure this is called eventually, or you\n * may get stuck in an infinite animation loop and crash the browser.\n */\nexport class AutoScroll {\n  /**\n   * Creates an AutoScroll instance for a specified workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace Workspace to scroll.\n   * @constructor\n   */\n  constructor(workspace) {\n    /**\n     * Workspace to scroll.\n     * @protected {!Blockly.WorkspaceSvg}\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * Current active vector representing scroll velocity in pixels per\n     * millisecond in each direction.\n     * @protected {!Blockly.utils.Coordinate}\n     */\n    this.activeScrollVector_ = new Blockly.utils.Coordinate(0, 0);\n\n    /**\n     * ID of active requestAnimationFrame callback key.\n     * @type {number}\n     * @protected\n     */\n    this.animationFrameId_ = 0;\n\n    /**\n     * Time in ms last animation frame was run.\n     * @type {number}\n     * @protected\n     */\n    this.lastTime_ = Date.now();\n\n    /**\n     * Whether the scroll animation should continue. If this is false, the next\n     * animation frame will not be requested.\n     * @type {boolean}\n     * @protected\n     */\n    this.shouldAnimate_ = false;\n  }\n\n  /**\n   * Cancels the current autoscroll and resets properties.\n   */\n  stopAndDestroy() {\n    this.activeScrollVector_ = new Blockly.utils.Coordinate(0, 0);\n    this.shouldAnimate_ = false;\n    cancelAnimationFrame(this.animationFrameId_);\n    this.animationFrameId_ = 0;\n  }\n\n  /**\n   * Ticks scrolling behavior and triggers another\n   * frame request.\n   * @param {number} now Current time in ms. This is usually passed\n   *     automatically by `requestAnimationFrame`.\n   * @protected\n   */\n  nextAnimationStep_(now) {\n    if (this.shouldAnimate_) {\n      const delta = now - this.lastTime_;\n      this.lastTime_ = now;\n      // This method could be called multiple times per ms, and we only want to\n      // scroll if we should actually move.\n      if (delta > 0) {\n        this.scrollTick_(delta);\n      }\n\n      this.animationFrameId_ = requestAnimationFrame((time) =>\n        this.nextAnimationStep_(time),\n      );\n    }\n  }\n\n  /**\n   * Perform scroll given time passed.\n   * @param {number} msPassed Number of ms since last scroll tick.\n   * @protected\n   */\n  scrollTick_(msPassed) {\n    const scrollDx = this.activeScrollVector_.x * msPassed;\n    const scrollDy = this.activeScrollVector_.y * msPassed;\n    this.scrollWorkspaceWithBlock(scrollDx, scrollDy);\n  }\n\n  /**\n   * Scrolls the workspace the given amount during a block drag.\n   * Also updates the dragger based on the amount actually scrolled.\n   * @param {number} scrollDx Amount to scroll in horizontal direction.\n   * @param {number} scrollDy Amount to scroll in vertical direction.\n   */\n  scrollWorkspaceWithBlock(scrollDx, scrollDy) {\n    const oldLocation = getTranslation(this.workspace_);\n\n    // As we scroll, we shouldn't expand past the content area that existed\n    // before the block was picked up. Therefore, we use cached ContentMetrics\n    // so that the content area does not change as we scroll.\n    const metricsManager = /** @type {ScrollMetricsManager} */ (\n      this.workspace_.getMetricsManager()\n    );\n    metricsManager.useCachedContentMetrics = true;\n    const newX = this.workspace_.scrollX + scrollDx;\n    const newY = this.workspace_.scrollY + scrollDy;\n    this.workspace_.scroll(newX, newY);\n    metricsManager.useCachedContentMetrics = false;\n\n    const newLocation = getTranslation(this.workspace_);\n\n    // How much we actually ended up scrolling.\n    const deltaX = newLocation.x - oldLocation.x;\n    const deltaY = newLocation.y - oldLocation.y;\n\n    // If we did scroll, we need to let the dragger know by how much.\n    // The dragger will update its values so that things like connection\n    // markers will stay consistent.\n    if (deltaX || deltaY) {\n      this.workspace_.currentGesture_\n        .getCurrentDragger()\n        .moveBlockWhileDragging(deltaX, deltaY);\n    }\n  }\n\n  /**\n   * Updates the scroll vector for the current autoscroll and begins the\n   * animation if needed.\n   * @param {!Blockly.utils.Coordinate} scrollVector New scroll velocity vector\n   *     in pixels per ms.\n   */\n  updateProperties(scrollVector) {\n    this.activeScrollVector_ = scrollVector;\n    this.shouldAnimate_ = true;\n\n    // Start new animation if there isn't one going.\n    if (this.animationFrameId_ == 0) {\n      this.lastTime_ = Date.now();\n      this.nextAnimationStep_(this.lastTime_);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview This adds a method to the block dragger to allow a block\n * to be moved when it is being dragged.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {AutoScroll} from './AutoScroll';\n\n/**\n * @typedef {!Object<string, !Array<!Blockly.utils.Coordinate>>}\n */\nlet CandidateScrolls;\n\n/**\n * Configuration for edge scrolling behavior.\n * @typedef {object} EdgeScrollOptions\n * @property {number=} slowBlockSpeed Pixels per ms to scroll when the block is\n * near the edge of the workspace.\n * @property {number=}fastBlockSpeed Pixels per ms to scroll when the block is\n * far past the edge of the workspace.\n * @property {number=} slowBlockStartDistance Distance in workspace units that\n * the edge of the block is from the edge of the viewport before the\n * corresponding scroll speed will be used. Can be negative to start scrolling\n * before the block extends over the edge.\n * @property {number=} fastBlockStartDistance Same as above, for fast speed.\n * Must be larger than `slowBlockStartDistance`.\n * @property {number=} oversizeBlockThreshold If a block takes up this\n * percentage of the viewport or more, it will be considered oversized. Rather\n * than using the block edge, we use the mouse cursor plus the given margin size\n * to activate block-based scrolling.\n * @property {number=} oversizeBlockMargin Cursor margin to use for oversized\n * blocks. A bigger value will cause the workspace to scroll sooner, i.e., the\n * mouse can be further inward from the edge when scrolling begins.\n * @property {number=} slowMouseSpeed Pixels per ms to\n * scroll when the mouse is near the edge of the workspace.\n * @property {number=} fastMouseSpeed Pixels per ms to\n * scroll when the mouse is far past the edge of the workspace.\n * @property {number=} slowMouseStartDistance Distance in workspace units that\n * the mouse is from the edge of the viewport before the corresponding scroll\n * speed will be used. Can be negative to start scrolling before the mouse\n * extends over the edge.\n * @property {number=} fastMouseStartDistance Same as above, for fast speed.\n * Must be larger than `slowMouseStartDistance`.\n */\nexport let EdgeScrollOptions;\n\n/** @type {!EdgeScrollOptions} */\nconst defaultOptions = {\n  slowBlockSpeed: 0.28,\n  fastBlockSpeed: 1.4,\n  slowBlockStartDistance: 0,\n  fastBlockStartDistance: 50,\n  oversizeBlockThreshold: 0.85,\n  oversizeBlockMargin: 15,\n  slowMouseSpeed: 0.5,\n  fastMouseSpeed: 1.6,\n  slowMouseStartDistance: 0,\n  fastMouseStartDistance: 35,\n};\n\n/**\n * A block dragger that adds the functionality for a block to be moved while\n * someone is dragging it.\n */\nexport class ScrollBlockDragger extends Blockly.BlockDragger {\n  /** @override */\n  constructor(block, workspace) {\n    super(block, workspace);\n\n    /**\n     * How much the block has been moved due to scrolling.\n     * @type {!Blockly.utils.Coordinate}\n     * @protected\n     */\n    this.scrollDelta_ = new Blockly.utils.Coordinate(0, 0);\n\n    /**\n     * How much the block has been moved due to dragging.\n     * @type {!Blockly.utils.Coordinate}\n     * @protected\n     */\n    this.dragDelta_ = new Blockly.utils.Coordinate(0, 0);\n\n    // TODO(maribethb): Use `isMoveable` etc. to get this list\n    /**\n     * Possible directions the workspace could be scrolled.\n     * @type {!Array<string>}\n     * @protected\n     */\n    this.scrollDirections_ = ['top', 'bottom', 'left', 'right'];\n  }\n\n  /**\n   * Updates the location of the block that is being dragged.\n   * @param {number} deltaX Horizontal offset in pixel units.\n   * @param {number} deltaY Vertical offset in pixel units.\n   */\n  moveBlockWhileDragging(deltaX, deltaY) {\n    this.scrollDelta_.x -= deltaX;\n    this.scrollDelta_.y -= deltaY;\n\n    // The total amount the block has moved since being picked up.\n    const totalDelta = Blockly.utils.Coordinate.sum(\n      this.scrollDelta_,\n      this.dragDelta_,\n    );\n\n    const delta = this.pixelsToWorkspaceUnits_(totalDelta);\n    const newLoc = Blockly.utils.Coordinate.sum(this.startXY_, delta);\n\n    // Make the block stay under the cursor.\n    this.draggingBlock_.moveDuringDrag(newLoc);\n\n    this.dragIcons_(totalDelta);\n  }\n\n  /**\n   * Passes the total amount the block has moved (both from dragging and from\n   * scrolling) since it was picked up.\n   * @override\n   */\n  startDrag(currentDragDeltaXY, healStack) {\n    const totalDelta = Blockly.utils.Coordinate.sum(\n      this.scrollDelta_,\n      currentDragDeltaXY,\n    );\n    super.startDrag(totalDelta, healStack);\n    this.dragDelta_ = currentDragDeltaXY;\n  }\n\n  /**\n   * Passes the total amount the block has moved (both from dragging and from\n   * scrolling) since it was picked up.\n   * @override\n   */\n  drag(e, currentDragDeltaXY) {\n    const totalDelta = Blockly.utils.Coordinate.sum(\n      this.scrollDelta_,\n      currentDragDeltaXY,\n    );\n    super.drag(e, totalDelta);\n    this.dragDelta_ = currentDragDeltaXY;\n\n    if (ScrollBlockDragger.edgeScrollEnabled) {\n      this.scrollWorkspaceWhileDragging_(e);\n    }\n  }\n\n  /**\n   * @override\n   */\n  endDrag(e, currentDragDeltaXY) {\n    super.endDrag(e, currentDragDeltaXY);\n\n    this.stopAutoScrolling();\n  }\n\n  /**\n   * Passes the total amount the block has moved (both from dragging and from\n   * scrolling) since it was picked up.\n   * @override\n   */\n  getNewLocationAfterDrag_(currentDragDeltaXY) {\n    const newValues = {};\n    const totalDelta = Blockly.utils.Coordinate.sum(\n      this.scrollDelta_,\n      currentDragDeltaXY,\n    );\n    newValues.delta = this.pixelsToWorkspaceUnits_(totalDelta);\n    newValues.newLocation = Blockly.utils.Coordinate.sum(\n      this.startXY_,\n      newValues.delta,\n    );\n\n    return newValues;\n  }\n\n  /**\n   * May scroll the workspace as a block is dragged.\n   * If a block is dragged near the edge of the workspace, this method will\n   * cause the workspace to scroll in the direction the block is being\n   * dragged. The workspace will not resize as the block is dragged. The\n   * workspace should appear to move out from under the block, i.e., the block\n   * should stay under the user's mouse.\n   * @param {!Event} e The mouse/touch event for the drag.\n   * @protected\n   */\n  scrollWorkspaceWhileDragging_(e) {\n    /**\n     * Unit vector for each direction that could be scrolled. This vector will\n     * be scaled to get the calculated velocity in each direction. Must be a\n     * dict because the properties are accessed based on the members of\n     * `this.scrollDirections_`.\n     * @dict\n     * @private\n     */\n    this.SCROLL_DIRECTION_VECTORS_ = {\n      top: new Blockly.utils.Coordinate(0, 1),\n      bottom: new Blockly.utils.Coordinate(0, -1),\n      left: new Blockly.utils.Coordinate(1, 0),\n      right: new Blockly.utils.Coordinate(-1, 0),\n    };\n    const mouse = Blockly.utils.svgMath.screenToWsCoordinates(\n      this.workspace_,\n      new Blockly.utils.Coordinate(e.clientX, e.clientY),\n    );\n\n    /**\n     * List of possible scrolls in each direction. This will be modified in\n     * place. Must be a dict because the properties are accessed based on the\n     * members of `this.scrollDirections_`.\n     * @dict\n     * @type {!CandidateScrolls}\n     */\n    const candidateScrolls = {\n      top: [],\n      bottom: [],\n      left: [],\n      right: [],\n    };\n\n    // Get ViewMetrics in workspace coordinates.\n    const viewMetrics = this.workspace_\n      .getMetricsManager()\n      .getViewMetrics(true);\n\n    // Get possible scroll velocities based on the location of both the block\n    // and the mouse.\n\n    this.computeBlockCandidateScrolls_(candidateScrolls, viewMetrics, mouse);\n    this.computeMouseCandidateScrolls_(candidateScrolls, viewMetrics, mouse);\n    // Calculate the final scroll vector we should actually use.\n    const overallScrollVector = this.getOverallScrollVector_(candidateScrolls);\n\n    // If the workspace should not be scrolled any longer, cancel the\n    // autoscroll.\n    if (\n      Blockly.utils.Coordinate.equals(\n        overallScrollVector,\n        new Blockly.utils.Coordinate(0, 0),\n      )\n    ) {\n      this.stopAutoScrolling();\n      return;\n    }\n\n    // Update the autoscroll or start a new one.\n    this.activeAutoScroll_ =\n      this.activeAutoScroll_ || new AutoScroll(this.workspace_);\n    this.activeAutoScroll_.updateProperties(overallScrollVector);\n  }\n\n  /**\n   * There could be multiple candidate scrolls for each direction, such as one\n   * for block position and one for mouse position. We should first find the\n   * fastest scroll in each direction. Then, we sum those to find the overall\n   * scroll vector.\n   *\n   * For example, we may have a fast block scroll and a slow\n   * mouse scroll candidate in both the top and left directions. First, we\n   * reduce to only the fast block scroll. Then, we sum the vectors in each\n   * direction to get a resulting fast scroll in a diagonal direction to the\n   * top left.\n   * @param {!CandidateScrolls} candidateScrolls Existing lists of candidate\n   *     scrolls. Will be modified in place.\n   * @returns {!Blockly.utils.Coordinate} Overall scroll vector.\n   * @protected\n   */\n  getOverallScrollVector_(candidateScrolls) {\n    let overallScrollVector = new Blockly.utils.Coordinate(0, 0);\n    for (const direction of this.scrollDirections_) {\n      const fastestScroll = candidateScrolls[direction].reduce(\n        (fastest, current) => {\n          if (!fastest) {\n            return current;\n          }\n          return Blockly.utils.Coordinate.magnitude(fastest) >\n            Blockly.utils.Coordinate.magnitude(current)\n            ? fastest\n            : current;\n        },\n        new Blockly.utils.Coordinate(0, 0),\n      ); // Initial value\n      overallScrollVector = Blockly.utils.Coordinate.sum(\n        overallScrollVector,\n        fastestScroll,\n      );\n    }\n    return overallScrollVector;\n  }\n\n  /**\n   * Gets the candidate scrolls based on the position of the block on the\n   * workspace. If the block is near/over the edge, a candidate scroll will be\n   * added based on the options provided.\n   *\n   * This method can be overridden to further customize behavior, e.g. To add\n   * a third speed option.\n   * @param {!CandidateScrolls} candidateScrolls Existing list of candidate\n   *     scrolls. Will be modified in place.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *     for the workspace.\n   * @param {!Blockly.utils.Coordinate} mouse Mouse coordinates.\n   * @protected\n   */\n  computeBlockCandidateScrolls_(candidateScrolls, viewMetrics, mouse) {\n    const blockOverflows = this.getBlockBoundsOverflows_(viewMetrics, mouse);\n    for (const direction of this.scrollDirections_) {\n      const overflow = blockOverflows[direction];\n      if (overflow > ScrollBlockDragger.options.slowBlockStartDistance) {\n        const speed =\n          overflow > ScrollBlockDragger.options.fastBlockStartDistance\n            ? ScrollBlockDragger.options.fastBlockSpeed\n            : ScrollBlockDragger.options.slowBlockSpeed;\n        const scrollVector = this.SCROLL_DIRECTION_VECTORS_[direction]\n          .clone()\n          .scale(speed);\n        candidateScrolls[direction].push(scrollVector);\n      }\n    }\n  }\n\n  /**\n   * Gets the candidate scrolls based on the position of the mouse cursor\n   * relative to the workspace. If the mouse is near/over the edge, a\n   * candidate scroll will be added based on the options provided.\n   *\n   * This method can be overridden to further customize behavior, e.g. To add\n   * a third speed option.\n   * @param {!CandidateScrolls} candidateScrolls Existing list of candidate\n   *     scrolls. Will be modified in place.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *     for the workspace.\n   * @param {!Blockly.utils.Coordinate} mouse Mouse coordinates.\n   * @protected\n   */\n  computeMouseCandidateScrolls_(candidateScrolls, viewMetrics, mouse) {\n    const mouseOverflows = this.getMouseOverflows_(viewMetrics, mouse);\n    for (const direction of this.scrollDirections_) {\n      const overflow = mouseOverflows[direction];\n      if (overflow > ScrollBlockDragger.options.slowMouseStartDistance) {\n        const speed =\n          overflow > ScrollBlockDragger.options.fastMouseStartDistance\n            ? ScrollBlockDragger.options.fastMouseSpeed\n            : ScrollBlockDragger.options.slowMouseSpeed;\n        const scrollVector = this.SCROLL_DIRECTION_VECTORS_[direction]\n          .clone()\n          .scale(speed);\n        candidateScrolls[direction].push(scrollVector);\n      }\n    }\n  }\n\n  /**\n   * Gets the amount of overflow of a box relative to the workspace viewport.\n   *\n   * The value for each direction will be how far the given block edge is from\n   * the given edge of the viewport. If the block edge is outside the\n   * viewport, the value will be positive. If the block edge is inside the\n   * viewport, the value will be negative.\n   *\n   * This method also checks for oversized blocks. If the block is very large\n   * relative to the viewport size, then we will actually use a small zone\n   * around the cursor, rather than the edge of the block, to calculate the\n   * overflow values. This calculation is done independently in both the\n   * horizontal and vertical directions. These values can be configured in the\n   * options for the plugin.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *     for the workspace.\n   * @param {!Blockly.utils.Coordinate} mouse Mouse coordinates.\n   * @returns {!Object<string, number>} An object describing the amount of\n   *     overflow in each direction.\n   * @protected\n   */\n  getBlockBoundsOverflows_(viewMetrics, mouse) {\n    const blockBounds = this.draggingBlock_.getBoundingRectangle();\n\n    // Handle large blocks. If the block is nearly as tall as the viewport,\n    // use a margin around the cursor rather than the height of the block.\n    const blockHeight = blockBounds.bottom - blockBounds.top;\n    if (\n      blockHeight >\n      viewMetrics.height * ScrollBlockDragger.options.oversizeBlockThreshold\n    ) {\n      blockBounds.top = Math.max(\n        blockBounds.top,\n        mouse.y - ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n      blockBounds.bottom = Math.min(\n        blockBounds.bottom,\n        mouse.y + ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n    }\n\n    // Same logic, but for block width.\n    const blockWidth = blockBounds.right - blockBounds.left;\n    if (\n      blockWidth >\n      viewMetrics.width * ScrollBlockDragger.options.oversizeBlockThreshold\n    ) {\n      blockBounds.left = Math.max(\n        blockBounds.left,\n        mouse.x - ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n      blockBounds.right = Math.min(\n        blockBounds.right,\n        mouse.x + ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n    }\n\n    // The coordinate system is negative in the top and left directions, and\n    // positive in the bottom and right directions. Therefore, the direction\n    // of the comparison must be switched for bottom and right.\n    return {\n      top: viewMetrics.top - blockBounds.top,\n      bottom: -(viewMetrics.top + viewMetrics.height - blockBounds.bottom),\n      left: viewMetrics.left - blockBounds.left,\n      right: -(viewMetrics.left + viewMetrics.width - blockBounds.right),\n    };\n  }\n\n  /**\n   * Gets the amount of overflow of the mouse coordinates relative to the\n   * viewport.\n   *\n   * The value for each direction will be how far the pointer is from\n   * the given edge of the viewport. If the pointer is outside the viewport,\n   * the value will be positive. If the pointer is inside the viewport, the\n   * value will be negative.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *     for the workspace.\n   * @param {!Blockly.utils.Coordinate} mouse Mouse coordinates.\n   * @returns {!Object<string, number>} An object describing the amount of\n   *     overflow in each direction.\n   * @protected\n   */\n  getMouseOverflows_(viewMetrics, mouse) {\n    // The coordinate system is negative in the top and left directions, and\n    // positive in the bottom and right directions. Therefore, the direction\n    // of the comparison must be switched for bottom and right.\n    return {\n      top: viewMetrics.top - mouse.y,\n      bottom: -(viewMetrics.top + viewMetrics.height - mouse.y),\n      left: viewMetrics.left - mouse.x,\n      right: -(viewMetrics.left + viewMetrics.width - mouse.x),\n    };\n  }\n\n  /**\n   * Cancel any AutoScroll. This must be called when there is no need to\n   * scroll further, e.g., when no longer dragging near the edge of the\n   * workspace, or when no longer dragging at all.\n   */\n  stopAutoScrolling() {\n    if (this.activeAutoScroll_) {\n      this.activeAutoScroll_.stopAndDestroy();\n    }\n    this.activeAutoScroll_ = null;\n  }\n}\n\n/**\n * Whether the behavior to scroll the workspace when a block is dragged near\n * the edge is enabled.\n * @type {boolean}\n */\nScrollBlockDragger.edgeScrollEnabled = true;\n\n/**\n * Configuration options for the scroll-options settings.\n * @type {!EdgeScrollOptions}\n */\nScrollBlockDragger.options = defaultOptions;\n\n/**\n * Update the scroll options. Only the properties actually included in the\n * `options` parameter will be set. Any unspecified options will use the\n * previously set value (where the initial value is from `defaultOptions`).\n * Therefore, do not pass in any options with explicit `undefined` or `null`\n * values. The plugin will break. Just leave them out of the object if you\n * don't want to change the default value.\n *\n * This method is safe to call multiple times. Subsequent calls will add onto\n * previous calls, not completely overwrite them. That is, if you call this\n * with:\n *\n *     `updateOptions({fastMouseSpeed: 5});\n *     updateOptions({slowMouseSpeed: 2});`.\n *\n * Then the final options used will include both `fastMouseSpeed: 5` and\n * `slowMouseSpeed: 2` with all other options being the default values.\n * @param {!EdgeScrollOptions} options Object containing any or all of\n *     the available options. Any properties not present will use the existing\n *     value.\n */\nScrollBlockDragger.updateOptions = function (options) {\n  ScrollBlockDragger.options = {...ScrollBlockDragger.options, ...options};\n};\n\n/**\n * Resets the options object to the default options.\n */\nScrollBlockDragger.resetOptions = function () {\n  ScrollBlockDragger.options = defaultOptions;\n};\n\nBlockly.registry.register(\n  Blockly.registry.Type.BLOCK_DRAGGER,\n  'ScrollBlockDragger',\n  ScrollBlockDragger,\n);\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport Blockly from 'blockly/core';\nimport {EdgeScrollOptions, ScrollBlockDragger} from './ScrollBlockDragger';\nimport {getTranslation} from './utils';\n\n/**\n * A Blockly plugin that adds additional features related to scrolling and\n * dragging on workspaces. This plugin adds the ability to: a) use the\n * mousewheel to scroll the workspace while a block is being dragged, and b)\n * scroll the workspace automatically when a block is dragged near the edge.\n *\n * All behavior is customizable. See the README for more information.\n */\nexport class ScrollOptions {\n  /**\n   * Constructor for ScrollOptions plugin.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace that the plugin will\n   *     be added to.\n   */\n  constructor(workspace) {\n    /**\n     * The workspace.\n     * @type {!Blockly.WorkspaceSvg}\n     * @protected\n     */\n    this.workspace_ = workspace;\n  }\n\n  /**\n   * Initialize plugin with optional options. If no options are provided, both\n   * plugin features are enabled with default settings. The plugin is configured\n   * here as a convenience. See the README for more information on configuring\n   * the plugin after initialization.\n   * @param {{enableWheelScroll: (boolean|undefined),\n   * enableEdgeScroll: (boolean|undefined),\n   * edgeScrollOptions: (!EdgeScrollOptions|undefined)}=} options The\n   * configuration options for the plugin. `enableWheelScroll` and\n   * `enableEdgeScroll` are both true by default and control whether the\n   * behavior to scroll with the mouse wheel while dragging and scroll when a\n   * block is near the edge of the workspace are enabled, respectively.\n   * `edgeScrollOptions` is an optional configuration for the edge scrolling\n   * behavior. See `ScrollBlockDrager.updateOptions` for more details.\n   */\n  init(\n    {\n      enableWheelScroll = true,\n      enableEdgeScroll = true,\n      edgeScrollOptions = null,\n    } = {\n      enableWheelScroll: true,\n      enableEdgeScroll: true,\n      edgeScrollOptions: null,\n    },\n  ) {\n    if (enableWheelScroll) {\n      this.enableWheelScroll();\n    } else {\n      this.disableWheelScroll();\n    }\n\n    ScrollBlockDragger.edgeScrollEnabled = enableEdgeScroll;\n\n    if (edgeScrollOptions) {\n      ScrollBlockDragger.updateOptions(edgeScrollOptions);\n    }\n  }\n\n  /**\n   * Enables scrolling with mousewheel during block drag.\n   */\n  enableWheelScroll() {\n    if (this.wheelEvent_) {\n      // Already enabled.\n      return;\n    }\n\n    // TODO(blockly/#7157): We should maybe add an accessor for the svgGroup_?\n    this.wheelEvent_ = Blockly.browserEvents.conditionalBind(\n      this.workspace_.svgGroup_,\n      'wheel',\n      this,\n      this.onMouseWheel_,\n    );\n  }\n\n  /**\n   * Disables scrolling with mousewheel during block drag.\n   */\n  disableWheelScroll() {\n    if (!this.wheelEvent_) {\n      // Already disabled.\n      return;\n    }\n    Blockly.browserEvents.unbind(this.wheelEvent_);\n    this.wheelEvent_ = null;\n  }\n\n  /**\n   * Enables scrolling when block is dragged near edge.\n   */\n  enableEdgeScroll() {\n    ScrollBlockDragger.edgeScrollEnabled = true;\n  }\n\n  /**\n   * Disables scrolling when block is dragged near edge.\n   */\n  disableEdgeScroll() {\n    ScrollBlockDragger.edgeScrollEnabled = false;\n  }\n\n  /**\n   * Updates edge scroll options. See ScrollBlockDragger for specific settings.\n   * Any values left unspecified will not be overwritten and will retain their\n   * previous values.\n   * @param {!EdgeScrollOptions} options Edge scroll options.\n   */\n  updateEdgeScrollOptions(options) {\n    ScrollBlockDragger.updateOptions(options);\n  }\n\n  /**\n   * Scrolls the workspace with the mousewheel while a block is being dragged.\n   * Translates the currently dragged block as the user scrolls the workspace,\n   * so that the block does not appear to move.\n   * @param {!Event} e Mouse wheel event.\n   */\n  onMouseWheel_(e) {\n    const canWheelMove =\n      this.workspace_.options.moveOptions &&\n      this.workspace_.options.moveOptions.wheel;\n    const currentGesture = this.workspace_.getGesture(e);\n\n    // Do not try to scroll if we are not dragging a block, or the workspace\n    // does not allow moving by wheel.\n    if (\n      !canWheelMove ||\n      !currentGesture ||\n      !(currentGesture.getCurrentDragger() instanceof Blockly.BlockDragger)\n    ) {\n      return;\n    }\n\n    // Figure out the desired location to scroll to.\n    const scrollDelta = Blockly.browserEvents.getScrollDeltaPixels(e);\n    if (e.shiftKey) {\n      // Scroll horizontally (based on vertical scroll delta).\n      const temp = scrollDelta.x;\n      scrollDelta.x = scrollDelta.y;\n      scrollDelta.y = temp;\n    }\n    const x = this.workspace_.scrollX - scrollDelta.x;\n    const y = this.workspace_.scrollY - scrollDelta.y;\n\n    const oldLocation = getTranslation(this.workspace_);\n\n    // Try to scroll to the desired location.\n    this.workspace_.getMetricsManager().useCachedContentMetrics = true;\n    this.workspace_.scroll(x, y);\n    this.workspace_.getMetricsManager().useCachedContentMetrics = false;\n\n    const newLocation = getTranslation(this.workspace_);\n\n    // How much we actually ended up scrolling.\n    const deltaX = newLocation.x - oldLocation.x;\n    const deltaY = newLocation.y - oldLocation.y;\n\n    if (deltaX || deltaY) {\n      currentGesture.getCurrentDragger().moveBlockWhileDragging(deltaX, deltaY);\n      e.preventDefault();\n    }\n  }\n}\n\nexport * from './ScrollBlockDragger';\nexport * from './ScrollMetricsManager';\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ScrollMetricsManager","constructor","workspace","super","useCachedContentMetrics","contentMetrics","getContentMetrics","getTranslation","ws","splitted","svgBlockCanvas_","getAttribute","split","x","Number","y","Blockly","utils","Coordinate","AutoScroll","workspace_","activeScrollVector_","animationFrameId_","lastTime_","Date","now","shouldAnimate_","stopAndDestroy","cancelAnimationFrame","nextAnimationStep_","delta","scrollTick_","requestAnimationFrame","time","msPassed","scrollDx","scrollDy","scrollWorkspaceWithBlock","oldLocation","metricsManager","getMetricsManager","newX","scrollX","newY","scrollY","scroll","newLocation","deltaX","deltaY","currentGesture_","getCurrentDragger","moveBlockWhileDragging","updateProperties","scrollVector","defaultOptions","slowBlockSpeed","fastBlockSpeed","slowBlockStartDistance","fastBlockStartDistance","oversizeBlockThreshold","oversizeBlockMargin","slowMouseSpeed","fastMouseSpeed","slowMouseStartDistance","fastMouseStartDistance","ScrollBlockDragger","block","scrollDelta_","dragDelta_","scrollDirections_","totalDelta","pixelsToWorkspaceUnits_","newLoc","startXY_","draggingBlock_","moveDuringDrag","dragIcons_","startDrag","currentDragDeltaXY","healStack","drag","e","edgeScrollEnabled","scrollWorkspaceWhileDragging_","endDrag","stopAutoScrolling","getNewLocationAfterDrag_","newValues","SCROLL_DIRECTION_VECTORS_","top","bottom","left","right","mouse","clientX","clientY","candidateScrolls","viewMetrics","getViewMetrics","computeBlockCandidateScrolls_","computeMouseCandidateScrolls_","overallScrollVector","getOverallScrollVector_","activeAutoScroll_","direction","fastestScroll","reduce","fastest","current","blockOverflows","getBlockBoundsOverflows_","overflow","options","speed","clone","scale","push","mouseOverflows","getMouseOverflows_","blockBounds","getBoundingRectangle","height","Math","max","min","width","updateOptions","resetOptions","ScrollOptions","init","enableWheelScroll","enableEdgeScroll","edgeScrollOptions","disableWheelScroll","wheelEvent_","svgGroup_","onMouseWheel_","disableEdgeScroll","updateEdgeScrollOptions","canWheelMove","moveOptions","wheel","currentGesture","getGesture","scrollDelta","shiftKey","temp","preventDefault"],"sourceRoot":""}